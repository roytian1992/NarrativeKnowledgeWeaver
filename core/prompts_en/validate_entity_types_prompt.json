{
  "id": "entity_type_merge_prompt",
  "category": "regular_function",
  "name": "Entity Type Merging Judgment Prompt (Chain of Thought Version, Single Entity Multiple Types)",
  "description": "Used to determine whether certain types need to be merged among multiple candidate entity types for the same entity, based on the provided context, and provide a merge mapping; if no merge is needed, an empty array is returned.",
  "template": "You are a knowledge graph construction expert. Task: For multiple candidate entity types of the \"same entity\", based on the provided contextual evidence, determine whether certain types need to be merged into another type. Please perform rigorous chain-of-thought reasoning internally, but the reasoning process should not be exposed in the final output, only the JSON result. \n\n[Input]\n{context}\n\n[Chain of Thought Steps (Internal reasoning only, do not output)]\n1. Extract the set of candidate types, and the evidence for each type in the context (definition/occurrence snippets/roles/constraints).\n2. Compare type relationships one by one: semantic equivalence / superordinate/subordinate (A⊂B or B⊂A) / different semantic dimensions (can coexist).\n3. Merging criteria:\n   - Semantic equivalence: Expresses the same category in the context of this entity, merged into a more stable, more specific target type.\n   - Semantic tightening: There is a superordinate/subordinate relationship and the context clearly tightens to the subordinate type, and the superordinate type no longer provides independent information value, then the superordinate is merged into the subordinate.\n   - Label redundancy/synonymous alias: Different names but equivalent in project specifications, merged into a standardized type name.\n   - Common special cases: If \"Concept\" and a more specific type (e.g., Character/Object/Location/Event/Action, etc.) appear simultaneously in the candidate set, and the entity has been concretized in the context, then \"Concept\" is merged into that specific type.\n4. Non-merging clauses:\n   - Different semantic dimensions can coexist (e.g., Location and Object are both valid and have evidence).\n   - Different levels of abstraction but need to be retained in the context (both general categories and instantiated roles provide information value).\n   - Insufficient evidence or conflicts do not merge.\n5. Target type selection: Prioritize selecting a more specific, more context-fitting, more informative, and more stable type as the merge target; do not create new types, only select from the candidate set.\n6. Consistency check: Deduplication; no self-mapping (from==to) and no cycles (A→B and B→A); only use type names that appeared in the input.\n\n[Output Format (Strictly follow)]\nPlease return the result only in the following JSON:\n\n```json\n{{\n  \"filtering_rules\": [\n    {{ \"type1\": \"type2\" }},\n    {{ \"type3\": \"type2\" }}\n  ]\n}}\n```\nMeans merge type1 to type2, and type3 to type2.\n\nIf no merge at all, return:\n\n```json\n{\n  \"filtering_rules\": []\n}\n```\n\n[Strict Requirements]\n- Only output the above JSON object, do not output explanations or extra fields.\n- Field names remain consistent: filtering_rules.\n- Ensure valid JSON, can be directly parsed.\n- Only use type names that appeared in the input, do not create new types.",
  "variables": [
    {
      "name": "context",
      "description": "Candidate types and evidence context for the same entity (type list, definition/specifications, occurrence context snippets, task domain rules, etc.)"
    }
  ]
}
