{
  "id": "entity_disambiguation_prompt",
  "category": "regular_function",
  "name": "Entity Merging Judgment Prompt (Story-Context Enhanced, with Model Differentiation and \"Instance First\" Rule)",
  "description": "Determine whether a set of entity names in a story context refer to the same entity, and output structured merge suggestions for knowledge-graph disambiguation. Adds \"instance first\" and naming-priority rules to avoid merging specific individuals (e.g., proper nouns, nicknames) into generic category names (e.g., \"mechanical dog\").",
  "template": "You are a knowledge-graph construction expert. Your task is to judge, within a story context, which of a set of potentially ambiguous entity names should be merged as the same entity (e.g., aliases, short names, honorifics) and which should remain distinct.\n\nBase your judgment on **story narrative and character identity**: even if names are similar, do not merge when they represent different identities, impostors, stand-ins, parallel-world versions, or different phases of a character.\n\nBelow are the entities to analyze:\n\n{entity_descriptions}\n\n---\n\n## Decision Rules (must follow)\n1. **Name similarity**: spelling closeness and naming style are supportive signals only; they cannot decide a merge by themselves.\n2. **Identity & semantic consistency**: the entities must describe the same role identity, background, behavioral traits, and narrative function.\n3. **Story & faction consistency**: they must inhabit the same setting, faction/affiliation, timeline, or worldbuilding.\n4. **Conflicts & differences take precedence**: if there is an adversarial relation, a split between alias and real name, parallel versions, or different-stage personas/hosts, **do not merge**.\n5. **Model/version distinction**: if the name contains model, serial, batch, or version markers (e.g., \"Pro\", \"2021\", \"550A\"), treat them as **different entities**.\n6. **Instance First (key)**: when comparing a **specific individual** (proper name/nickname/call sign/unique ID) vs. a **generic category/species/role/equipment common name**, **never merge the individual into the category**. If they are confirmed to be different labels for the **same unique object**, prefer the **individual name as `canonical_name`**, and the category name may appear only as an alias; if the category label is generic and not uniquely referring, **do not merge** and place it under `unmerged`.\n7. **Naming priority (high → low)**: **proper name (legal/canonical) > stable nickname/moniker > call sign/code > office/role title > species/category common name**. When a merge is valid, use the higher-priority name as `canonical_name`.\n8. **Language & translation variants**: normalized names across languages/transliterations/simplified–traditional variants may be merged for the same entity; but **translation differences must not cross identity/version boundaries**.\n9. **Multiple instances within a class**: for robots, pets, soldiers, etc., if there is no unique identifier or continuous narrative binding, default to **no merge**.\n\n---\n\n## Output Format (strict)\nReturn **only** the following JSON object:\n\n```json\n{{\n  \"merges\": [\n    {{\n      \"canonical_name\": \"Canonical Name\",\n      \"aliases\": [\"Alias 1\", \"Alias 2\"],\n      \"reason\": \"Brief justification referencing rule numbers\"\n    }}\n  ],\n  \"unmerged\": [\n    {{\n      \"name\": \"Name not merged\",\n      \"reason\": \"Brief justification referencing rule numbers\"\n    }}\n  ]\n}}\n```\n\nIf none should be merged, set `merges` to an empty array and list all items under `unmerged`. Return **only** this JSON object—no extra text.",
  "variables": [
    {
      "name": "entity_descriptions",
      "description": "Provide a brief description for each entity name (e.g., type, identity, behavior, faction, context, appearance scene)."
    }
  ]
}
