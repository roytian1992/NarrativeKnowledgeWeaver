{
  "id": "entity_type_merge_prompt",
  "category": "regular_function",
  "name": "实体类型合并判断提示词（思维链版，单实体多类型｜维度守恒）",
  "description": "在同一实体的多个候选实体类型之间，基于上下文判断是否需要合并，并输出合并映射；若不需要合并则返回空数组。特别强调：跨语义维度（如“角色身份/社会位格=Character”与“物理载体/可占据空间=Object”）可并存，默认不合并。",
  "template": "你是一位知识图谱构建专家。任务：针对“同一实体”的多个候选实体类型，依据提供的上下文证据，判断是否需要将某些类型合并为另一类型。请在内部进行严谨的思维链推理，但最终输出中不得暴露推理过程，只输出 JSON 结果。\n\n【输入】\n{context}\n\n【思维链步骤（仅内在推理，不要输出）】\n1. 提取候选类型集合，以及每个类型在上下文中的证据（定义/出现片段/角色/约束）。\n2. 标注语义维度：\n   - 角色/身份维度：Character、Organization、Faction 等；\n   - 物理/载体维度：Object、Device、Vehicle 等；\n   - 抽象/概念维度：Concept、Theme、Idea 等；\n   - 时空/事件维度：Location、Event、Action 等。\n3. 逐对比对类型关系：语义等价 / 上下位（A⊂B 或 B⊂A）/ 不同语义维度（可并存）。\n4. 合并准则（仅在满足其一时合并）：\n   - 【等价】在该实体语境下两类型语义等价（同一维度、同一指称），合并为更稳定且更具体的目标类型；\n   - 【收紧】同一维度存在上/下位关系且上下文明确收紧到下位类型，且上位类型不再提供独立信息价值，则把上位并入下位；\n   - 【同义别名】命名不同但在项目规范中等价，合并为规范类型名；\n   - 【常见特例】Concept + 具体类型（如 Character/Object/Location/Event/Action）且上下文已具体化，则将 Concept 并入该具体类型。\n5. 不合并条款（重要，优先级最高）：\n   - 【维度守恒】不同语义维度可并存，默认不合并。例如，'星星'可能即是一个角色又是一个物体，此时根据语义不合并。如果 `Character` 与 `Object` 之间的类型并存（如“星星”既是角色又是物体），则不进行合并，除非有明确证据表明它们是同一个实体的误标。\n   - 证据不足或存在冲突时不合并。\n6. 目标类型选择（当且仅当判定需要合并时）：\n   - 同一维度内，优先选择更具体、与上下文更贴合、信息量更大且更稳定的类型；\n   - 禁止创建新类型，只能在候选集中选择；\n   - 一致性检查：去重；禁止自映射（from==to）与环（A→B 且 B→A）。\n7. 安全阈值：若无法以高置信度证明需合并，则不合并。\n\n【输出格式（严格遵循）】\n请仅以如下 JSON 返回结果：\n\n```json\n{{\n  \"filtering_rules\": [\n    {{ \"type1\": \"type2\" }},\n    {{ \"type3\": \"type2\" }}\n  ]\n}}\n```\n表示把 type1 合并到 type2，type3 也合并到 type2。\n\n如完全不合并，则返回：\n\n```json\n{{\n  \"filtering_rules\": []\n}}\n```\n\n【严格要求】\n- 只输出上述 JSON 对象，不要输出解释或多余字段。\n- 字段名保持一致：filtering_rules。\n- 确保合法 JSON，可被直接解析。\n- 仅使用输入中出现过的类型名称，不创建新类型。\n- 对 Character vs Object 的并存场景，默认不合并；仅在明确误标或无独立证据的一方时才合并，并给出该方向的映射（优先 Object→Character）。",
  "variables": [
    {
      "name": "context",
      "description": "同一实体的候选类型与证据上下文（类型列表、定义/规范、出现语境片段、任务域规则等）"
    }
  ]
}
